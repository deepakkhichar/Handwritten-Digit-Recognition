# -*- coding: utf-8 -*-
"""A2_problem1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ci0F-_xmiwQopeL52Cxhu6bAvqi8dtWR
"""

import torch
import torchvision
from torchvision import transforms, datasets

input_size = 28*28 
 hidden_layer_1_size = 500
 hidden_layer_2_size = 500 
 output_size = 10
 epochs = 250
 batch_size = 64
 learning_rate = 0.01

#Extracting MNIST data and Normalising it
transform = transforms.Compose([transforms.ToTensor(),transforms.Normalize((0.5,), (0.5,))])

training = datasets.MNIST("", train=True, download = True,transform= transform)
testing =  datasets.MNIST("", train=False, download = True,transform= transform)

#training_set, validation_set and testing_set
train, val = torch.utils.data.random_split(training, [50000, 10000])
print("Number of images in Training set: ",len(train))
print("Number of images in Validation set: ",len(val))
print("Number of images in Testing set: ",len(testing))

train_set = torch.utils.data.DataLoader(train, batch_size=batch_size, shuffle=True)
validation_set = torch.utils.data.DataLoader(val, batch_size=batch_size, shuffle=False)
test_set = torch.utils.data.DataLoader(testing, batch_size=batch_size, shuffle=False)

#Neural Network
import torch.nn as nn
model = nn.Sequential(nn.Linear(input_size, hidden_layer_1_size), 
                      nn.ReLU(),
                      nn.Linear(hidden_layer_1_size, hidden_layer_2_size),
                      nn.ReLU(),
                      nn.Linear(hidden_layer_2_size, output_size),
                      nn.LogSoftmax(dim=1))

import torch.optim as optim
optimizer = optim.SGD(model.parameters(), lr=learning_rate) 

criterion=nn.CrossEntropyLoss()

import numpy as np
trainingloss=np.zeros(epochs)
trainingaccuracy=np.zeros(epochs)
validationloss=np.zeros(epochs)
validationaccuracy=np.zeros(epochs)

x_axis=np.zeros(epochs)

for epoch in range(epochs):
  ####################
  ### Train Loop #####
  ####################
  
  model.train()
  train_loss=0
  for data in train_set:
    X,Y=data
    X=X.view(-1,28*28)
    optimizer.zero_grad()
    outputs=model(X)
    loss=criterion(outputs,Y)
    loss.backward()
    optimizer.step()
    train_loss += loss.item()
  trainingloss[epoch]=train_loss/len(train_set)

  #########################
  ### Validation Loop #####
  #########################
  model.eval()
  valid_loss = 0
  for data in validation_set:
    X,Y=data
    X=X.view(-1,28*28)
    outputs=model(X)
    loss = criterion(outputs,Y)
    valid_loss += loss.item()
  validationloss[epoch]=valid_loss/len(validation_set)

  #validation accuracy
  correct = 0
  total = 0
  for data in validation_set:
    X, Y = data
    X=X.view(-1,28*28)
    output = model(X)
    _,predicted=torch.max(output.data, 1)
    total += Y.size(0)
    correct += (predicted == Y).sum()
  vaccuracy = 100 * correct / total
  validationaccuracy[epoch]=vaccuracy.item()

  # Training Accuracy
  correct = 0
  total = 0
  for data in train_set:
    X, Y = data
    X=X.view(-1,28*28)
    output = model(X)
    _,predicted=torch.max(output.data, 1)
    total += Y.size(0)
    correct += (predicted == Y).sum()
  taccuracy = 100 * correct / total
  trainingaccuracy[epoch]=taccuracy.item()

  x_axis[epoch]=epoch+1

  print("Epoch:",epoch+1,"  Trainloss: ",trainingloss[epoch],"  TrainAccuracy: ",trainingaccuracy[epoch],"  ValidationLoss: ",validationloss[epoch],"  ValidationAccuracy: ",validationaccuracy[epoch])

# Ploting the error and classification accuracy on both training and validation data over the epochs
import matplotlib.pyplot as plt
plt.figure()
plt.title(" Training Error  Vs Number of Epochs")
plt.ylabel("Training Error")
plt.xlabel("Number of Epochs")
plt.plot(x_axis,trainingloss)

plt.figure()
plt.title(" Training Accuracy  Vs Number of Epochs")
plt.ylabel("Training Accuracy")
plt.xlabel("Number of Epochs")
plt.plot(x_axis,trainingaccuracy)

plt.figure()
plt.title(" Validation Error  Vs Number of Epochs")
plt.ylabel("Validation Error")
plt.xlabel("Number of Epochs")
plt.plot(x_axis,validationloss)

plt.figure()
plt.title(" Validation Accuracy  Vs Number of Epochs")
plt.ylabel("Validation Accuracy")
plt.xlabel("Number of Epochs")
plt.plot(x_axis,validationaccuracy)

# Training Accuracy
correct = 0
total = 0
with torch.no_grad():
  for data in train_set:
    X, Y = data
    X=X.view(-1,28*28)
    output = model(X)
    _,predicted=torch.max(output.data, 1)
    total += Y.size(0)
    correct += (predicted == Y).sum()
training_accuracy = 100 * correct / total


# Testing Accuracy
correct = 0
total = 0
with torch.no_grad():
  for data in test_set:
    X, Y = data
    X=X.view(-1,28*28)
    output = model(X)
    _,predicted=torch.max(output.data, 1)
    total += Y.size(0)
    correct += (predicted == Y).sum()

testing_accuracy = 100 * correct / total

print("Training Accuracy: ",training_accuracy.item())
print("Testing Accuracy: ",testing_accuracy.item())

"""## L2 Regularization """

weight_decay=0.01

lmodel = nn.Sequential(nn.Linear(input_size, hidden_layer_1_size), 
                      nn.ReLU(),
                      nn.Linear(hidden_layer_1_size, hidden_layer_2_size),
                      nn.ReLU(),
                      nn.Linear(hidden_layer_2_size, output_size),
                      nn.LogSoftmax(dim=1))
loptimizer = optim.SGD(lmodel.parameters(), lr=learning_rate, weight_decay=weight_decay)

ltrainingloss=np.zeros(epochs)
ltrainingaccuracy=np.zeros(epochs)
lvalidationloss=np.zeros(epochs)
lvalidationaccuracy=np.zeros(epochs)

for epoch in range(epochs):
  ####################
  ### Train Loop #####
  ####################
  
  lmodel.train()
  ltrain_loss=0
  for data in train_set:
    X,Y=data
    X=X.view(-1,28*28)
    loptimizer.zero_grad()
    loutputs=lmodel(X)
    lloss=criterion(loutputs,Y)
    lloss.backward()
    loptimizer.step()
    ltrain_loss += lloss.item()
  ltrainingloss[epoch]=ltrain_loss/len(train_set)

  #########################
  ### Validation Loop #####
  #########################
  lmodel.eval()
  lvalid_loss = 0
  for data in validation_set:
    X,Y=data
    X=X.view(-1,28*28)
    loutputs=lmodel(X)
    lloss = criterion(loutputs,Y)
    lvalid_loss += lloss.item()
  lvalidationloss[epoch]=lvalid_loss/len(validation_set)

  #validation accuracy
  lcorrect = 0
  ltotal = 0
  for data in validation_set:
    X, Y = data
    X=X.view(-1,28*28)
    loutput = lmodel(X)
    _,lpredicted=torch.max(loutput.data, 1)
    ltotal += Y.size(0)
    lcorrect += (lpredicted == Y).sum()
  laccuracy = 100 * lcorrect / ltotal
  lvalidationaccuracy[epoch]=laccuracy.item()

  # Training Accuracy
  lcorrect = 0
  ltotal = 0
  for data in train_set:
    X, Y = data
    X=X.view(-1,28*28)
    loutput = lmodel(X)
    _,lpredicted=torch.max(loutput.data, 1)
    ltotal += Y.size(0)
    lcorrect += (lpredicted == Y).sum()
  ltaccuracy = 100 * lcorrect / ltotal
  ltrainingaccuracy[epoch]=ltaccuracy.item()

  print("Epoch:",epoch+1,"  Trainloss: ",ltrainingloss[epoch],"  TrainAccuracy: ",ltrainingaccuracy[epoch],"  ValidationLoss: ",lvalidationloss[epoch],"  ValidationAccuracy: ",lvalidationaccuracy[epoch])

# Ploting the error and classification accuracy on both training and validation data over the epochs
import matplotlib.pyplot as plt
plt.figure()
plt.title(" Training Error  Vs Number of Epochs")
plt.ylabel("Training Error")
plt.xlabel("Number of Epochs")
plt.plot(x_axis,ltrainingloss)

plt.figure()
plt.title(" Training Accuracy  Vs Number of Epochs")
plt.ylabel("Training Accuracy")
plt.xlabel("Number of Epochs")
plt.plot(x_axis,ltrainingaccuracy)

plt.figure()
plt.title(" Validation Error  Vs Number of Epochs")
plt.ylabel("Validation Error")
plt.xlabel("Number of Epochs")
plt.plot(x_axis,lvalidationloss)

plt.figure()
plt.title(" Validation Accuracy  Vs Number of Epochs")
plt.ylabel("Validation Accuracy")
plt.xlabel("Number of Epochs")
plt.plot(x_axis,lvalidationaccuracy)

# Training Accuracy
lcorrect = 0
ltotal = 0
with torch.no_grad():
  for data in train_set:
    X, Y = data
    X=X.view(-1,28*28)
    loutput = lmodel(X)
    _,lpredicted=torch.max(loutput.data, 1)
    ltotal += Y.size(0)
    lcorrect += (lpredicted == Y).sum()
ltraining_accuracy = 100 * lcorrect / ltotal


# Testing Accuracy
lcorrect = 0
ltotal = 0
with torch.no_grad():
  for data in test_set:
    X, Y = data
    X=X.view(-1,28*28)
    loutput = lmodel(X)
    _,lpredicted=torch.max(loutput.data, 1)
    ltotal += Y.size(0)
    lcorrect += (lpredicted == Y).sum()

ltesting_accuracy = 100 * lcorrect / ltotal

print("Training Accuracy: ",ltraining_accuracy.item())
print("Testing Accuracy: ",ltesting_accuracy.item())

"""## Dropout

"""

dmodel = nn.Sequential(nn.Linear(input_size, hidden_layer_1_size), 
                      nn.ReLU(),
                      nn.Dropout(p=0.5),
                      nn.Linear(hidden_layer_1_size, hidden_layer_2_size),
                      nn.ReLU(),
                      nn.Dropout(p=0.5),
                      nn.Linear(hidden_layer_2_size, output_size),
                      nn.LogSoftmax(dim=1))
doptimizer = optim.SGD(dmodel.parameters(), lr=learning_rate)

dtrainingloss=np.zeros(epochs)
dtrainingaccuracy=np.zeros(epochs)
dvalidationloss=np.zeros(epochs)
dvalidationaccuracy=np.zeros(epochs)

for epoch in range(epochs):
  ####################
  ### Train Loop #####
  ####################
  
  dmodel.train()
  dtrain_loss=0
  for data in train_set:
    X,Y=data
    X=X.view(-1,28*28)
    doptimizer.zero_grad()
    doutputs=dmodel(X)
    dloss=criterion(doutputs,Y)
    dloss.backward()
    doptimizer.step()
    dtrain_loss += dloss.item()
  dtrainingloss[epoch]=dtrain_loss/len(train_set)

  #########################
  ### Validation Loop #####
  #########################
  dmodel.eval()
  dvalid_loss = 0
  for data in validation_set:
    X,Y=data
    X=X.view(-1,28*28)
    doutputs=dmodel(X)
    dloss = criterion(doutputs,Y)
    dvalid_loss += dloss.item()
  dvalidationloss[epoch]=dvalid_loss/len(validation_set)

  #validation accuracy
  dcorrect = 0
  dtotal = 0
  for data in validation_set:
    X, Y = data
    X=X.view(-1,28*28)
    doutput = dmodel(X)
    _,dpredicted=torch.max(doutput.data, 1)
    dtotal += Y.size(0)
    dcorrect += (dpredicted == Y).sum()
  daccuracy = 100 * dcorrect / dtotal
  dvalidationaccuracy[epoch]=daccuracy.item()

  # Training Accuracy
  dcorrect = 0
  dtotal = 0
  for data in train_set:
    X, Y = data
    X=X.view(-1,28*28)
    doutput = dmodel(X)
    _,dpredicted=torch.max(doutput.data, 1)
    dtotal += Y.size(0)
    dcorrect += (dpredicted == Y).sum()
  dtaccuracy = 100 * dcorrect / dtotal
  dtrainingaccuracy[epoch]=dtaccuracy.item()

  print("Epoch:",epoch+1,"  Trainloss: ",dtrainingloss[epoch],"  TrainAccuracy: ",dtrainingaccuracy[epoch],"  ValidationLoss: ",dvalidationloss[epoch],"  ValidationAccuracy: ",dvalidationaccuracy[epoch])

# Ploting the error and classification accuracy on both training and validation data over the epochs
import matplotlib.pyplot as plt
plt.figure()
plt.title(" Training Error  Vs Number of Epochs")
plt.ylabel("Training Error")
plt.xlabel("Number of Epochs")
plt.plot(x_axis,dtrainingloss)

plt.figure()
plt.title(" Training Accuracy  Vs Number of Epochs")
plt.ylabel("Training Accuracy")
plt.xlabel("Number of Epochs")
plt.plot(x_axis,dtrainingaccuracy)

plt.figure()
plt.title(" Validation Error  Vs Number of Epochs")
plt.ylabel("Validation Error")
plt.xlabel("Number of Epochs")
plt.plot(x_axis,dvalidationloss)

plt.figure()
plt.title(" Validation Accuracy  Vs Number of Epochs")
plt.ylabel("Validation Accuracy")
plt.xlabel("Number of Epochs")
plt.plot(x_axis,dvalidationaccuracy)

# Training Accuracy
dcorrect = 0
dtotal = 0
with torch.no_grad():
  for data in train_set:
    X, Y = data
    X=X.view(-1,28*28)
    doutput = dmodel(X)
    _,dpredicted=torch.max(doutput.data, 1)
    dtotal += Y.size(0)
    dcorrect += (dpredicted == Y).sum()
dtraining_accuracy = 100 * dcorrect / dtotal


# Testing Accuracy
dcorrect = 0
dtotal = 0
with torch.no_grad():
  for data in test_set:
    X, Y = data
    X=X.view(-1,28*28)
    doutput = dmodel(X)
    _,dpredicted=torch.max(doutput.data, 1)
    dtotal += Y.size(0)
    dcorrect += (dpredicted == Y).sum()

dtesting_accuracy = 100 * dcorrect / dtotal

print("Training Accuracy: ",dtraining_accuracy.item())
print("Testing Accuracy: ",dtesting_accuracy.item())

"""## Early Stopping"""

emodel = nn.Sequential(nn.Linear(input_size, hidden_layer_1_size), 
                      nn.ReLU(),
                      nn.Linear(hidden_layer_1_size, hidden_layer_2_size),
                      nn.ReLU(),
                      nn.Linear(hidden_layer_2_size, output_size),
                      nn.LogSoftmax(dim=1))
eoptimizer = optim.SGD(emodel.parameters(), lr=learning_rate)

etrainingloss=np.zeros(epochs)
etrainingaccuracy=np.zeros(epochs)
evalidationloss=np.zeros(epochs)
evalidationaccuracy=np.zeros(epochs)

best_accuracy=0
bestepoch=0
for epoch in range(epochs):
  ####################
  ### Train Loop #####
  ####################
  
  emodel.train()
  etrain_loss=0
  for data in train_set:
    X,Y=data
    X=X.view(-1,28*28)
    eoptimizer.zero_grad()
    eoutputs=emodel(X)
    eloss=criterion(eoutputs,Y)
    eloss.backward()
    eoptimizer.step()
    etrain_loss += eloss.item()
  etrainingloss[epoch]=etrain_loss/len(train_set)

  #########################
  ### Validation Loop #####
  #########################
  emodel.eval()
  evalid_loss = 0
  for data in validation_set:
    X,Y=data
    X=X.view(-1,28*28)
    eoutputs=emodel(X)
    eloss = criterion(eoutputs,Y)
    evalid_loss += eloss.item()
  evalidationloss[epoch]=evalid_loss/len(validation_set)

  #validation accuracy
  ecorrect = 0
  etotal = 0
  for data in validation_set:
    X, Y = data
    X=X.view(-1,28*28)
    eoutput = emodel(X)
    _,epredicted=torch.max(eoutput.data, 1)
    etotal += Y.size(0)
    ecorrect += (epredicted == Y).sum()
  eaccuracy = 100 * ecorrect / etotal
  evalidationaccuracy[epoch]=eaccuracy.item()

  # Training Accuracy
  ecorrect = 0
  etotal = 0
  for data in train_set:
    X, Y = data
    X=X.view(-1,28*28)
    eoutput = emodel(X)
    _,epredicted=torch.max(eoutput.data, 1)
    etotal += Y.size(0)
    ecorrect += (epredicted == Y).sum()
  etaccuracy = 100 * ecorrect / etotal
  etrainingaccuracy[epoch]=etaccuracy.item()

  if evalidationaccuracy[epoch] > best_accuracy:
    best_accuracy = evalidationloss[epoch]
    bestepoch=epoch
    torch.save(emodel, 'best_model')

  print("Epoch:",epoch+1,"  Trainloss: ",etrainingloss[epoch],"  TrainAccuracy: ",etrainingaccuracy[epoch],"  ValidationLoss: ",evalidationloss[epoch],"  ValidationAccuracy: ",evalidationaccuracy[epoch])

print("Optimal number of Epoch for early stopping: ",bestepoch+1)
emodel = torch.load('best_model')
emodel.eval()

# Ploting the error and classification accuracy on both training and validation data over the epochs
import matplotlib.pyplot as plt
plt.figure()
plt.title(" Training Error  Vs Number of Epochs")
plt.ylabel("Training Error")
plt.xlabel("Number of Epochs")
plt.plot(x_axis[:bestepoch],etrainingloss[:bestepoch])

plt.figure()
plt.title(" Training Accuracy  Vs Number of Epochs")
plt.ylabel("Training Accuracy")
plt.xlabel("Number of Epochs")
plt.plot(x_axis[:bestepoch],etrainingaccuracy[:bestepoch])

plt.figure()
plt.title(" Validation Error  Vs Number of Epochs")
plt.ylabel("Validation Error")
plt.xlabel("Number of Epochs")
plt.plot(x_axis[:bestepoch],evalidationloss[:bestepoch])

plt.figure()
plt.title(" Validation Accuracy  Vs Number of Epochs")
plt.ylabel("Validation Accuracy")
plt.xlabel("Number of Epochs")
plt.plot(x_axis[:bestepoch],evalidationaccuracy[:bestepoch])

# Training Accuracy
ecorrect = 0
etotal = 0
with torch.no_grad():
  for data in train_set:
    X, Y = data
    X=X.view(-1,28*28)
    eoutput = emodel(X)
    _,epredicted=torch.max(eoutput.data, 1)
    etotal += Y.size(0)
    ecorrect += (epredicted == Y).sum()
etraining_accuracy = 100 * ecorrect / etotal


# Testing Accuracy
ecorrect = 0
etotal = 0
with torch.no_grad():
  for data in test_set:
    X, Y = data
    X=X.view(-1,28*28)
    eoutput = emodel(X)
    _,epredicted=torch.max(eoutput.data, 1)
    etotal += Y.size(0)
    ecorrect += (epredicted == Y).sum()

etesting_accuracy = 100 * ecorrect / etotal

print("Training Accuracy: ",etraining_accuracy.item())
print("Testing Accuracy: ",etesting_accuracy.item())